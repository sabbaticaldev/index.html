Project Path: /home/alanleal/Projects/bootstrapp/libs/backend/indexeddb

Source Tree:

```
indexeddb
├── utils.js
├── crud.js
└── index.js

```

`/home/alanleal/Projects/bootstrapp/libs/backend/indexeddb/utils.js`:

```````js
const promisifyRequest = (request) =>
  new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

const iterateCursor = (request, process) =>
  new Promise((resolve, reject) => {
    const items = [];
    request.onsuccess = () => {
      const cursor = request.result;
      if (cursor) {
        process(items, cursor);
        cursor.continue();
      } else {
        resolve(items);
      }
    };
    request.onerror = () => reject(request.error);
  });

const tableOperation = (table, mode, operation) =>
  table(mode, (store) => promisifyRequest(operation(store)));

const processKeys = (items, cursor) => items.push(cursor.key);
const processValues = (items, cursor) => items.push(cursor.value);
const processEntries = (items, cursor) => items.push([cursor.key, cursor.value]);

const entries = (table) =>
  tableOperation(table, "readonly", (store) =>
    store.getAll && store.getAllKeys
      ? Promise.all([
        promisifyRequest(store.getAllKeys()),
        promisifyRequest(store.getAll()),
      ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]))
      : iterateCursor(store.openCursor(), processEntries)
  );

const startsWith = (prefix, table, { index = true, keepKey = false } = {}) =>
  table("readonly", (store) => {
    const range = IDBKeyRange.bound(prefix, prefix + "\uffff");
    return iterateCursor(store.openCursor(range), (items, cursor) => {
      const id = keepKey ? cursor.key : cursor.key.split("_")[1];
      items.push(index ? id : { id, [prefix]: cursor.value });
    });
  });

const getCount = (table) => tableOperation(table, "readonly", (store) => store.count());
const isEmpty = (table) => getCount(table).then((count) => count === 0);
const clear = (table) => tableOperation(table, "readwrite", (store) => store.clear());
const keys = (table) => tableOperation(table, "readonly", (store) =>
  store.getAllKeys ? promisifyRequest(store.getAllKeys()) : iterateCursor(store.openCursor(), processKeys)
);
const values = (table) => tableOperation(table, "readonly", (store) =>
  store.getAll ? promisifyRequest(store.getAll()) : iterateCursor(store.openCursor(), processValues)
);

export {
  clear,
  entries,
  getCount,
  isEmpty,
  keys,
  promisifyRequest,
  startsWith,
  tableOperation,
  values
};

```````

`/home/alanleal/Projects/bootstrapp/libs/backend/indexeddb/crud.js`:

```````js
import { promisifyRequest, startsWith } from "./utils";

const getItem = (key, table) => table("readonly", (store) => promisifyRequest(store.get(key)));
const get = (keys, table) => table("readonly", (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));
const set = (entries, table) => table("readwrite", (store) => {
  entries.forEach(([key, value]) => store.put(value, key));
  return promisifyRequest(store.transaction);
});
const remove = (keys, table) => table("readwrite", (store) => {
  keys.forEach((key) => store.delete(key));
  return promisifyRequest(store.transaction);
});
const update = (key, updater, db) => db("readwrite", (store) =>
  promisifyRequest(store.get(key)).then((result) => {
    store.put(updater(result), key);
    return promisifyRequest(store.transaction);
  })
);
const setLastOp = async (key, value, { db, propKey }) => {
  const keys = await startsWith(propKey, db, { index: true, keepKey: true });
  await remove(keys, db);
  set([[key, value]], db);
};

export {
  get,
  getItem,
  remove,
  set,
  setLastOp,
  update};

```````

`/home/alanleal/Projects/bootstrapp/libs/backend/indexeddb/index.js`:

```````js
import { get, getItem, remove, set, setLastOp, update } from "./crud.js";
import { clear, entries, getCount, isEmpty, keys, promisifyRequest, startsWith, values } from "./utils.js";

const createStore = (dbName = "bootstrapp", storeName = "kv") => {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
};

const createDatabase = (dbName = "bootstrapp", storeNames = ["kv"], version = 1) =>
  new Promise((resolve, reject) => {
    const request = indexedDB.open(dbName, version);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      storeNames.forEach((storeName) => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName);
        }
      });
    };
    request.onerror = (event) => reject(new Error(`IndexedDB error: ${event.target.error}`));
    request.onsuccess = (event) => {
      const db = event.target.result;
      const stores = storeNames.reduce((acc, storeName) => {
        acc[storeName] = (txMode, callback) => new Promise((resolve, reject) => {
          try {
            const transaction = db.transaction(storeName, txMode);
            const objectStore = transaction.objectStore(storeName);
            Promise.resolve(callback(objectStore)).then(resolve).catch(reject);
          } catch (error) {
            reject(new Error("Transaction failed", error));
          }
        });
        return acc;
      }, {});
      resolve(stores);
    };
  });

const idbAdapter = {
  clear,
  entries,
  values,
  getCount,
  startsWith,
  keys,
  isEmpty,
  createStore,
  createDatabase,
  get,
  getItem,
  remove,
  set,
  setLastOp,
  update,
};

export default idbAdapter;

```````